---
title: Permission æƒé™ç³»ç»Ÿ
description: å·¥å…·æ‰§è¡Œæƒé™æ§åˆ¶å’Œå®¡æ‰¹æµç¨‹
navigation:
  icon: i-lucide-shield-check
---

# Permission æƒé™ç³»ç»Ÿ

Permission ç³»ç»Ÿæä¾›äº†çµæ´»çš„å·¥å…·æ‰§è¡Œæƒé™æ§åˆ¶ï¼Œæ”¯æŒä¸‰ç§å®¡æ‰¹æ¨¡å¼å’ŒåŸºäºè§„åˆ™çš„æ™ºèƒ½å†³ç­–ã€‚aster 1.x ç‰ˆæœ¬å¼•å…¥äº†ä¸ Claude Agent SDK å¯¹é½çš„å¢å¼ºæƒé™ç³»ç»Ÿã€‚

## ğŸ†• Claude Agent SDK é£æ ¼å¢å¼º

aster æ–°å¢äº† `EnhancedInspector`ï¼Œæä¾›ä»¥ä¸‹å¢å¼ºåŠŸèƒ½ï¼š

- **CanUseTool å›è°ƒ**: è‡ªå®šä¹‰æƒé™æ£€æŸ¥é€»è¾‘
- **æ²™ç®±é›†æˆ**: ä¸ SandboxSettings æ·±åº¦é›†æˆ
- **ä¼šè¯çº§è§„åˆ™**: ä¸´æ—¶è§„åˆ™ï¼Œä¼šè¯ç»“æŸè‡ªåŠ¨æ¸…é™¤
- **åŠ¨æ€æƒé™æ›´æ–°**: è¿è¡Œæ—¶æ·»åŠ /ç§»é™¤è§„åˆ™
- **è¿è§„è®°å½•**: è®°å½•å’ŒæŸ¥è¯¢æ²™ç®±è¿è§„

## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### ä¸‰ç§å®¡æ‰¹æ¨¡å¼

| æ¨¡å¼ | è¯´æ˜ | é€‚ç”¨åœºæ™¯ |
|------|------|----------|
| `auto_approve` | è‡ªåŠ¨æ‰¹å‡†æ‰€æœ‰æ“ä½œ | å¼€å‘æµ‹è¯•ã€å¯ä¿¡ç¯å¢ƒ |
| `smart_approve` | æ ¹æ®é£é™©çº§åˆ«æ™ºèƒ½å†³ç­– | **æ¨èé»˜è®¤æ¨¡å¼** |
| `always_ask` | æ‰€æœ‰æ“ä½œéƒ½éœ€ç¡®è®¤ | é«˜å®‰å…¨æ€§åœºæ™¯ |

### é£é™©çº§åˆ«

| çº§åˆ« | å·¥å…·ç¤ºä¾‹ | è¯´æ˜ |
|------|----------|------|
| **Low** | Read, List, Search | åªè¯»æ“ä½œï¼Œæ— å‰¯ä½œç”¨ |
| **Medium** | Write, Edit | æ–‡ä»¶ä¿®æ”¹ï¼Œæœ‰é™èŒƒå›´ |
| **High** | Bash, Delete, Http | ç³»ç»Ÿå‘½ä»¤ï¼Œç½‘ç»œè®¿é—® |

## ğŸ“Š æ¶æ„è®¾è®¡

```mermaid
graph TB
    Agent[Agent] --> Middleware[HITL Middleware]
    Middleware --> Inspector[Permission Inspector]
    
    Inspector --> Mode{å®¡æ‰¹æ¨¡å¼}
    Mode -->|auto_approve| Auto[è‡ªåŠ¨æ‰¹å‡†]
    Mode -->|smart_approve| Smart[æ™ºèƒ½å®¡æ‰¹]
    Mode -->|always_ask| Ask[æ€»æ˜¯è¯¢é—®]
    
    Smart --> Risk[é£é™©è¯„ä¼°]
    Risk --> Rules[è§„åˆ™åŒ¹é…]
    Rules --> Decision{å†³ç­–}
    
    Decision -->|Allow| Execute[æ‰§è¡Œå·¥å…·]
    Decision -->|Deny| Reject[æ‹’ç»æ‰§è¡Œ]
    Decision -->|Ask| Control[Control Channel]
    
    Control --> User[ç”¨æˆ·ç¡®è®¤]
    User --> Execute
    
    style Inspector fill:#3b82f6
    style Smart fill:#10b981
    style Control fill:#f59e0b
```

## ğŸš€ å¿«é€Ÿå¼€å§‹

### åˆ›å»º Inspector

```go
import "github.com/astercloud/aster/pkg/permission"

// ä½¿ç”¨æ™ºèƒ½å®¡æ‰¹æ¨¡å¼ï¼ˆæ¨èï¼‰
inspector, err := permission.NewInspector(
    permission.WithMode(permission.ModeSmartApprove),
)
if err != nil {
    log.Fatal(err)
}
```

### æ£€æŸ¥æƒé™

```go
ctx := context.Background()

result, err := inspector.Check(ctx, &permission.Request{
    ToolName:  "Bash",
    Arguments: map[string]any{
        "command": "rm -rf /tmp/test",
    },
})

if result.NeedsApproval {
    // éœ€è¦ç”¨æˆ·ç¡®è®¤
    fmt.Printf("éœ€è¦å®¡æ‰¹: %s (é£é™©: %s)\n", result.ToolName, result.RiskLevel)
} else if result.Decision == permission.DecisionAllow {
    // è‡ªåŠ¨æ‰¹å‡†
    fmt.Println("å·²æ‰¹å‡†æ‰§è¡Œ")
} else {
    // æ‹’ç»æ‰§è¡Œ
    fmt.Printf("æ‹’ç»: %s\n", result.Reason)
}
```

## ğŸ”§ å®¡æ‰¹æ¨¡å¼è¯¦è§£

### Auto Approve æ¨¡å¼

```go
inspector, _ := permission.NewInspector(
    permission.WithMode(permission.ModeAutoApprove),
)

// æ‰€æœ‰å·¥å…·éƒ½è‡ªåŠ¨æ‰¹å‡†
result, _ := inspector.Check(ctx, &permission.Request{
    ToolName: "Bash",
    Arguments: map[string]any{"command": "rm -rf /"},
})
// result.Decision == DecisionAllow
// result.NeedsApproval == false
```

::alert{type="warning"}
âš ï¸ Auto Approve æ¨¡å¼ä¼šæ‰¹å‡†æ‰€æœ‰æ“ä½œï¼Œä»…åœ¨å¼€å‘æµ‹è¯•æˆ–å®Œå…¨å¯ä¿¡çš„ç¯å¢ƒä¸­ä½¿ç”¨ã€‚
::

### Smart Approve æ¨¡å¼

```go
inspector, _ := permission.NewInspector(
    permission.WithMode(permission.ModeSmartApprove),
)

// åªè¯»æ“ä½œ - è‡ªåŠ¨æ‰¹å‡†
result, _ := inspector.Check(ctx, &permission.Request{
    ToolName: "Read",
    Arguments: map[string]any{"path": "main.go"},
})
// result.NeedsApproval == false

// å†™æ“ä½œ - éœ€è¦å®¡æ‰¹
result, _ = inspector.Check(ctx, &permission.Request{
    ToolName: "Write",
    Arguments: map[string]any{"path": "main.go", "content": "..."},
})
// result.NeedsApproval == true

// ç³»ç»Ÿå‘½ä»¤ - éœ€è¦å®¡æ‰¹
result, _ = inspector.Check(ctx, &permission.Request{
    ToolName: "Bash",
    Arguments: map[string]any{"command": "echo hello"},
})
// result.NeedsApproval == true
```

### Always Ask æ¨¡å¼

```go
inspector, _ := permission.NewInspector(
    permission.WithMode(permission.ModeAlwaysAsk),
)

// å³ä½¿åªè¯»æ“ä½œä¹Ÿéœ€è¦ç¡®è®¤
result, _ := inspector.Check(ctx, &permission.Request{
    ToolName: "Read",
    Arguments: map[string]any{"path": "main.go"},
})
// result.NeedsApproval == true
```

## ğŸ“ è§„åˆ™ç³»ç»Ÿ

### æ·»åŠ è§„åˆ™

```go
// å…è®¸æ‰€æœ‰è¯»å–æ“ä½œ
inspector.AddRule(&permission.Rule{
    Pattern:   "Read",
    Decision:  permission.DecisionAllowAlways,
    RiskLevel: permission.RiskLevelLow,
    Note:      "å…è®¸æ‰€æœ‰è¯»å–æ“ä½œ",
})

// ç¦æ­¢å±é™©å‘½ä»¤
inspector.AddRule(&permission.Rule{
    Pattern:   "Bash",
    Decision:  permission.DecisionDenyAlways,
    RiskLevel: permission.RiskLevelHigh,
    Conditions: []permission.Condition{
        {
            Field:    "command",
            Operator: "contains",
            Value:    "rm -rf",
        },
    },
    Note: "ç¦æ­¢å±é™©çš„åˆ é™¤å‘½ä»¤",
})

// å…è®¸å†™å…¥ç‰¹å®šç›®å½•
inspector.AddRule(&permission.Rule{
    Pattern:   "Write",
    Decision:  permission.DecisionAllowAlways,
    Conditions: []permission.Condition{
        {
            Field:    "path",
            Operator: "prefix",
            Value:    "/tmp/",
        },
    },
    Note: "å…è®¸å†™å…¥ä¸´æ—¶ç›®å½•",
})
```

### æ¡ä»¶è¿ç®—ç¬¦

| è¿ç®—ç¬¦ | è¯´æ˜ | ç¤ºä¾‹ |
|--------|------|------|
| `eq` | ç›¸ç­‰ | `command eq "ls"` |
| `ne` | ä¸ç­‰ | `path ne "/etc/passwd"` |
| `contains` | åŒ…å« | `command contains "rm"` |
| `prefix` | å‰ç¼€ | `path prefix "/home/"` |
| `suffix` | åç¼€ | `path suffix ".txt"` |
| `regex` | æ­£åˆ™ | `command regex "^git\s+"` |

### ä¸´æ—¶è§„åˆ™

```go
// åˆ›å»ºä¸´æ—¶è§„åˆ™ï¼ˆ1å°æ—¶åè¿‡æœŸï¼‰
expiry := time.Now().Add(time.Hour)
inspector.AddRule(&permission.Rule{
    Pattern:   "Bash",
    Decision:  permission.DecisionAllowAlways,
    ExpiresAt: &expiry,
    Note:      "ä¸´æ—¶å…è®¸ Bash å‘½ä»¤",
})
```

### è§„åˆ™æŒä¹…åŒ–

```go
// ä¿å­˜è§„åˆ™åˆ°æ–‡ä»¶
err := inspector.SaveRules()
// è§„åˆ™ä¿å­˜åˆ°: ~/.config/aster/permissions.json

// åˆ›å»ºæ—¶è‡ªåŠ¨åŠ è½½è§„åˆ™
inspector, _ := permission.NewInspector(
    permission.WithMode(permission.ModeSmartApprove),
    permission.WithAutoLoad(true),  // è‡ªåŠ¨åŠ è½½å·²ä¿å­˜çš„è§„åˆ™
)

// è‡ªå®šä¹‰è§„åˆ™æ–‡ä»¶è·¯å¾„
inspector, _ := permission.NewInspector(
    permission.WithPath("/custom/path/permissions.json"),
)
```

## ğŸ”— ä¸ Agent é›†æˆ

### ä½¿ç”¨ HITL ä¸­é—´ä»¶

```go
import (
    "github.com/astercloud/aster/pkg/middleware"
    "github.com/astercloud/aster/pkg/permission"
)

// åˆ›å»º Inspector
inspector, _ := permission.NewInspector(
    permission.WithMode(permission.ModeSmartApprove),
)

// åˆ›å»º HITL ä¸­é—´ä»¶
hitlMiddleware := middleware.NewHumanInTheLoopMiddleware(&middleware.HumanInTheLoopMiddlewareConfig{
    Inspector: inspector,
    ApprovalHandler: func(ctx context.Context, req *middleware.ReviewRequest) ([]middleware.Decision, error) {
        // è‡ªå®šä¹‰å®¡æ‰¹é€»è¾‘
        for _, action := range req.ActionRequests {
            fmt.Printf("éœ€è¦å®¡æ‰¹: %s\n", action.ToolName)
            // æ˜¾ç¤º UI æˆ–å‘½ä»¤è¡Œæç¤º...
        }
        return []middleware.Decision{{Type: middleware.DecisionApprove}}, nil
    },
})

// æ³¨å†Œä¸­é—´ä»¶
middleware.DefaultRegistry.Register("hitl", func(config *middleware.MiddlewareFactoryConfig) (middleware.Middleware, error) {
    return hitlMiddleware, nil
})

// åœ¨ Agent ä¸­ä½¿ç”¨
config := &types.AgentConfig{
    Middlewares: []string{"hitl"},
}
```

### Control Channel é›†æˆ

```go
// è®¢é˜… Control Channel
controlCh := agent.Subscribe([]types.AgentChannel{types.ChannelControl}, nil)

go func() {
    for event := range controlCh {
        switch e := event.Event.(type) {
        case *types.ControlPermissionRequiredEvent:
            // æ˜¾ç¤ºå®¡æ‰¹å¯¹è¯æ¡†
            approved := showApprovalDialog(e.ToolName, e.Arguments, e.RiskLevel)
            
            // å‘é€å†³å®š
            agent.RespondToPermission(e.RequestID, approved, "ç”¨æˆ·å†³å®š")
        }
    }
}()
```

## ğŸ“Š é£é™©è¯„ä¼°

### å†…ç½®é£é™©è§„åˆ™

```go
// è·å–å·¥å…·é£é™©çº§åˆ«
risk := inspector.AssessRisk(&permission.Request{
    ToolName:  "Bash",
    Arguments: map[string]any{"command": "curl http://..."},
})
// risk == RiskLevelHigh
```

### é£é™©è¯„ä¼°å› ç´ 

| å› ç´  | ä½é£é™© | é«˜é£é™© |
|------|--------|--------|
| å·¥å…·ç±»å‹ | Read, List | Bash, Delete |
| ç›®æ ‡è·¯å¾„ | å·¥ä½œç›®å½•å†… | ç³»ç»Ÿç›®å½• |
| å‘½ä»¤å†…å®¹ | æŸ¥è¯¢ç±» | ä¿®æ”¹/åˆ é™¤ç±» |
| ç½‘ç»œè®¿é—® | æ—  | å¤–éƒ¨è¯·æ±‚ |

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. åˆ†å±‚æƒé™ç­–ç•¥

```go
// å¼€å‘ç¯å¢ƒ
if env == "development" {
    inspector, _ = permission.NewInspector(
        permission.WithMode(permission.ModeAutoApprove),
    )
}

// ç”Ÿäº§ç¯å¢ƒ
if env == "production" {
    inspector, _ = permission.NewInspector(
        permission.WithMode(permission.ModeAlwaysAsk),
    )
}
```

### 2. ç™½åå•ä¼˜å…ˆ

```go
// æ·»åŠ å®‰å…¨å·¥å…·ç™½åå•
safeTools := []string{"Read", "List", "Search", "Glob"}
for _, tool := range safeTools {
    inspector.AddRule(&permission.Rule{
        Pattern:  tool,
        Decision: permission.DecisionAllowAlways,
    })
}
```

### 3. è®°å½•å®¡æ‰¹å†å²

```go
// è®°å½•æ‰€æœ‰å®¡æ‰¹å†³å®š
inspector.OnDecision(func(req *permission.Request, result *permission.Result) {
    log.Printf("Permission: tool=%s decision=%s reason=%s",
        req.ToolName, result.Decision, result.Reason)
})
```

## ğŸ” EnhancedInspector (Claude Agent SDK é£æ ¼)

`EnhancedInspector` æ˜¯å¢å¼ºç‰ˆæƒé™æ£€æŸ¥å™¨ï¼Œæ•´åˆäº† CanUseTool å›è°ƒã€æ²™ç®±é…ç½®å’Œè§„åˆ™ç®¡ç†ã€‚

### åˆ›å»º EnhancedInspector

```go
import (
    "github.com/astercloud/aster/pkg/permission"
    "github.com/astercloud/aster/pkg/types"
)

// é…ç½®æ²™ç®±è®¾ç½®
sandboxConfig := &types.SandboxConfig{
    Kind: types.SandboxKindLocal,
    Settings: &types.SandboxSettings{
        Enabled:                  true,
        AutoAllowBashIfSandboxed: true,
        ExcludedCommands:         []string{"git", "docker"},
        AllowUnsandboxedCommands: true,
    },
    PermissionMode: types.SandboxPermissionDefault,
}

// è‡ªå®šä¹‰æƒé™å›è°ƒ
canUseTool := func(
    ctx context.Context,
    toolName string,
    input map[string]any,
    opts *types.CanUseToolOptions,
) (*types.PermissionResult, error) {
    // é˜»æ­¢æ•æ„Ÿæ–‡ä»¶è®¿é—®
    if path, ok := input["path"].(string); ok {
        if path == "/etc/passwd" {
            return &types.PermissionResult{
                Behavior: "deny",
                Message:  "Access denied",
            }, nil
        }
    }
    return nil, nil // è®©æƒé™ç³»ç»Ÿå†³ç­–
}

// åˆ›å»ºå¢å¼ºæ£€æŸ¥å™¨
inspector := permission.NewEnhancedInspector(&permission.EnhancedInspectorConfig{
    Mode:          permission.ModeSmartApprove,
    SandboxConfig: sandboxConfig,
    CanUseTool:    canUseTool,
    PersistPath:   ".aster/permissions.json",
    AutoLoad:      true,
})
```

### CanUseTool å›è°ƒ

```go
type CanUseToolFunc func(
    ctx context.Context,
    toolName string,
    input map[string]any,
    opts *CanUseToolOptions,
) (*PermissionResult, error)

type CanUseToolOptions struct {
    Signal                 context.Context // å–æ¶ˆä¿¡å·
    Suggestions            []PermissionUpdate // å»ºè®®çš„æƒé™æ›´æ–°
    SandboxEnabled         bool // æ²™ç®±æ˜¯å¦å¯ç”¨
    BypassSandboxRequested bool // æ˜¯å¦è¯·æ±‚ç»•è¿‡æ²™ç®±
}

type PermissionResult struct {
    Behavior           string            // "allow" | "deny"
    UpdatedInput       map[string]any    // ä¿®æ”¹åçš„è¾“å…¥
    UpdatedPermissions []PermissionUpdate // æƒé™æ›´æ–°
    Message            string            // æ‹’ç»åŸå› 
    Interrupt          bool              // æ˜¯å¦ä¸­æ–­
}
```

### æƒé™æ£€æŸ¥æµç¨‹

```go
// æ‰§è¡Œæƒé™æ£€æŸ¥
call := &types.ToolCallSnapshot{
    ID:        "call-1",
    Name:      "Bash",
    Arguments: map[string]any{"command": "ls -la"},
}

result, err := inspector.Check(ctx, call)
if err != nil {
    log.Fatal(err)
}

if result.Allowed {
    fmt.Printf("âœ… Allowed (decided by: %s)\n", result.DecidedBy)
} else if result.NeedsApproval {
    fmt.Printf("â³ Needs approval (decided by: %s)\n", result.DecidedBy)
} else {
    fmt.Printf("ğŸš« Denied: %s\n", result.Message)
}
```

### æ£€æŸ¥ç»“æœ

```go
type CheckResult struct {
    Allowed         bool   // æ˜¯å¦å…è®¸
    NeedsApproval   bool   // æ˜¯å¦éœ€è¦å®¡æ‰¹
    DecidedBy       string // å†³ç­–æ¥æº
    Message         string // æ¶ˆæ¯
    Interrupt       bool   // æ˜¯å¦ä¸­æ–­
    UpdatedInput    map[string]any // ä¿®æ”¹åçš„è¾“å…¥
    ApprovalRequest *types.ControlPermissionRequiredEvent
}
```

### å†³ç­–æ¥æº (DecidedBy)

| å€¼ | è¯´æ˜ |
|----|------|
| `bypass_mode` | æƒé™æ¨¡å¼ä¸º bypass |
| `plan_mode` | æƒé™æ¨¡å¼ä¸º plan |
| `accept_edits_mode` | æƒé™æ¨¡å¼ä¸º acceptEdits |
| `canUseTool` | CanUseTool å›è°ƒå†³ç­– |
| `excluded_command` | å‘½ä»¤åœ¨æ’é™¤åˆ—è¡¨ |
| `sandbox_policy` | æ²™ç®±ç­–ç•¥æ‹’ç» |
| `auto_allow_bash` | AutoAllowBashIfSandboxed |
| `rule:xxx` | åŒ¹é…è§„åˆ™ xxx |
| `low_risk` | ä½é£é™©è‡ªåŠ¨æ‰¹å‡† |
| `medium_risk` | ä¸­é£é™©éœ€å®¡æ‰¹ |
| `high_risk` | é«˜é£é™©éœ€å®¡æ‰¹ |

### ä¼šè¯çº§è§„åˆ™

```go
// æ·»åŠ ä¼šè¯çº§è§„åˆ™ï¼ˆä¼šè¯ç»“æŸè‡ªåŠ¨æ¸…é™¤ï¼‰
inspector.addSessionRule(permission.Rule{
    Pattern:  "Write",
    Decision: permission.DecisionAllow,
    Note:     "Session auto-approved",
})

// æ¸…é™¤ä¼šè¯çº§è§„åˆ™
inspector.ClearSessionRules()
```

### åŠ¨æ€æƒé™æ›´æ–°

```go
// é€šè¿‡ CanUseTool è¿”å›æƒé™æ›´æ–°
return &types.PermissionResult{
    Behavior: "allow",
    UpdatedPermissions: []types.PermissionUpdate{
        {
            Type:        "addRules",
            Behavior:    "allow",
            Destination: "session", // æˆ– "project", "user"
            Rules: []types.PermissionRule{
                {ToolName: "Write", RuleContent: "auto-approved"},
            },
        },
    },
}, nil
```

### è¿è§„è®°å½•

```go
// è®°å½•è¿è§„
inspector.RecordViolation(types.SandboxViolation{
    Type:      "file",
    Path:      "/etc/passwd",
    Operation: "read",
    Blocked:   true,
    Timestamp: time.Now().Unix(),
    Details:   "Attempted to read system file",
})

// è·å–è¿è§„è®°å½•
violations := inspector.GetViolations()
for _, v := range violations {
    fmt.Printf("Violation: %s %s (%s)\n", v.Type, v.Path, v.Operation)
}
```

## ğŸ›ï¸ æƒé™æ¨¡å¼ (SandboxPermissionMode)

| æ¨¡å¼ | å¸¸é‡ | è¯´æ˜ |
|------|------|------|
| **é»˜è®¤** | `SandboxPermissionDefault` | æ ‡å‡†æƒé™æ£€æŸ¥æµç¨‹ |
| **æ¥å—ç¼–è¾‘** | `SandboxPermissionAcceptEdits` | è‡ªåŠ¨æ¥å—æ–‡ä»¶ç¼–è¾‘ |
| **ç»•è¿‡æƒé™** | `SandboxPermissionBypass` | ç»•è¿‡æ‰€æœ‰æƒé™æ£€æŸ¥ |
| **è§„åˆ’æ¨¡å¼** | `SandboxPermissionPlan` | åªè®°å½•ä¸æ‰§è¡Œ |

```go
sandboxConfig := &types.SandboxConfig{
    PermissionMode: types.SandboxPermissionAcceptEdits,
}
```

## âš ï¸ dangerouslyDisableSandbox

æ¨¡å‹å¯ä»¥åœ¨å·¥å…·è¾“å…¥ä¸­è¯·æ±‚ç»•è¿‡æ²™ç®±ï¼š

```go
// å·¥å…·è°ƒç”¨å‚æ•°
{
    "command": "sudo apt update",
    "dangerouslyDisableSandbox": true
}
```

å¤„ç†æµç¨‹ï¼š

1. æ£€æŸ¥ `AllowUnsandboxedCommands` é…ç½®
2. å¦‚æœä¸å…è®¸ï¼Œç›´æ¥æ‹’ç»
3. å¦‚æœå…è®¸ï¼Œæå‡é£é™©çº§åˆ«ï¼Œéœ€è¦ç”¨æˆ·å®¡æ‰¹

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [æ²™ç®±ç³»ç»Ÿ](/core-concepts/sandbox) - æ²™ç®±é…ç½®å’Œå®‰å…¨ç­–ç•¥
- [Human-in-the-Loop](/core-concepts/middleware#hitl) - HITL ä¸­é—´ä»¶è¯¦è§£
- [Guardrails](/security/guardrails) - å®‰å…¨é˜²æŠ¤ç³»ç»Ÿ
- [Recipe æƒé™é…ç½®](/guides/recipe#permission) - åœ¨ Recipe ä¸­é…ç½®æƒé™

## ğŸ”— ç¤ºä¾‹ä»£ç 

```bash
# è¿è¡Œ Permission ç¤ºä¾‹
go run ./examples/permission/

# è¿è¡Œ Sandbox Permission ç¤ºä¾‹ (Claude Agent SDK é£æ ¼)
go run ./examples/sandbox-permission/

# è¿è¡Œ Human-in-the-Loop ç¤ºä¾‹
go run ./examples/human-in-the-loop/
```

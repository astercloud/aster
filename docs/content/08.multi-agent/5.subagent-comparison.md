---
title: SubAgent å®ç°å¯¹æ¯”
description: Aster SubAgent vs Claude Codex SubAgent æ·±åº¦å¯¹æ¯”
navigation:
  icon: i-lucide-git-compare-arrows
---

# SubAgent å®ç°å¯¹æ¯”

å¯¹æ¯” Aster çš„ SubAgent å®ç°ä¸ Claude Extended Thinking (Codex) çš„ SubAgent æœºåˆ¶ã€‚

## ğŸ¯ Claude Codex SubAgent æ ¸å¿ƒç‰¹æ€§

Claude çš„ Extended Thinking æ¨¡å¼ä¸­ï¼ŒSubAgent æœ‰ä»¥ä¸‹å…³é”®ç‰¹æ€§ï¼š

### 1. **è‡ªåŠ¨çŠ¶æ€æŒä¹…åŒ–**
```
- SubAgent æ‰§è¡Œè¿‡ç¨‹ä¸­è‡ªåŠ¨ä¿å­˜çŠ¶æ€
- æ”¯æŒä¸­æ–­åæ¢å¤ï¼ˆResumeï¼‰
- çŠ¶æ€åŒ…æ‹¬ï¼šæ‰§è¡Œè¿›åº¦ã€ä¸­é—´ç»“æœã€å·¥å…·è°ƒç”¨å†å²
- æŒä¹…åŒ–åˆ°ç£ç›˜/æ•°æ®åº“
```

### 2. **é•¿æ—¶é—´è¿è¡Œæ”¯æŒ**
```
- SubAgent å¯ä»¥è¿è¡Œæ•°å°æ—¶ç”šè‡³æ•°å¤©
- ä¸» Agent ä¸éœ€è¦ç­‰å¾… SubAgent å®Œæˆ
- å¼‚æ­¥è½®è¯¢æœºåˆ¶æ£€æŸ¥ SubAgent çŠ¶æ€
- æ”¯æŒåå°æ‰§è¡Œ
```

### 3. **èµ„æºç›‘æ§å’Œé™åˆ¶**
```
- CPUã€å†…å­˜ã€ç£ç›˜ä½¿ç”¨ç›‘æ§
- è¶…æ—¶æ§åˆ¶
- èµ„æºé…é¢é™åˆ¶
- è‡ªåŠ¨æ¸…ç†æœºåˆ¶
```

### 4. **ä¸°å¯Œçš„ç”Ÿå‘½å‘¨æœŸç®¡ç†**
```
- Start: å¯åŠ¨ SubAgent
- Pause: æš‚åœæ‰§è¡Œ
- Resume: æ¢å¤æ‰§è¡Œ
- Stop: åœæ­¢æ‰§è¡Œ
- Query: æŸ¥è¯¢çŠ¶æ€å’Œè¾“å‡º
- Cleanup: æ¸…ç†èµ„æº
```

### 5. **è¿›ç¨‹çº§éš”ç¦»**
```
- æ¯ä¸ª SubAgent è¿è¡Œåœ¨ç‹¬ç«‹è¿›ç¨‹ä¸­
- å®Œå…¨çš„å†…å­˜éš”ç¦»
- ç‹¬ç«‹çš„æ–‡ä»¶ç³»ç»Ÿè§†å›¾ï¼ˆå¯é€‰ï¼‰
- æ²™ç®±æ‰§è¡Œç¯å¢ƒ
```

## ğŸ“‹ Aster SubAgent å½“å‰å®ç°

### âœ… å·²å®ç°çš„ç‰¹æ€§

| ç‰¹æ€§ | å®ç°çŠ¶æ€ | è¯´æ˜ |
|------|---------|------|
| **åŸºæœ¬ä»»åŠ¡å§”æ´¾** | âœ… å®Œæ•´ | é€šè¿‡ `task` å·¥å…·è°ƒç”¨ |
| **ä¸Šä¸‹æ–‡éš”ç¦»** | âœ… å®Œæ•´ | æ¯ä¸ª SubAgent ç‹¬ç«‹ä¸Šä¸‹æ–‡ |
| **å¹¶è¡Œæ‰§è¡Œ** | âœ… å®Œæ•´ | æ”¯æŒåŒæ—¶å¯åŠ¨å¤šä¸ª SubAgent |
| **ä¸“ä¸šåŒ–é…ç½®** | âœ… å®Œæ•´ | SubAgentSpec å®šä¹‰ä¸åŒç±»å‹ |
| **å·¥å…·é›†é…ç½®** | âœ… å®Œæ•´ | å¯ç»§æ‰¿æˆ–è‡ªå®šä¹‰å·¥å…· |
| **ä¸­é—´ä»¶ç»§æ‰¿** | âœ… å®Œæ•´ | çµæ´»çš„ä¸­é—´ä»¶æ ˆé…ç½® |
| **ç»“æœè¿”å›** | âœ… å®Œæ•´ | è¿”å›æ‘˜è¦ç»“æœç»™ä¸» Agent |

### âš ï¸ éƒ¨åˆ†å®ç°çš„ç‰¹æ€§

| ç‰¹æ€§ | å®ç°çŠ¶æ€ | è¯´æ˜ |
|------|---------|------|
| **çŠ¶æ€æŒä¹…åŒ–** | âš ï¸ éƒ¨åˆ† | `FileSubagentManager` æœ‰åŸºç¡€å®ç°ï¼Œä½†æœªå®Œå…¨é›†æˆ |
| **ç”Ÿå‘½å‘¨æœŸç®¡ç†** | âš ï¸ éƒ¨åˆ† | æœ‰ Start/Stopï¼Œç¼ºå°‘ Pause/Resume |
| **èµ„æºç›‘æ§** | âš ï¸ éƒ¨åˆ† | æœ‰åŸºç¡€çš„ CPU/å†…å­˜ç›‘æ§ï¼Œä½†ä¸å®Œå–„ |
| **è¿›ç¨‹éš”ç¦»** | âš ï¸ éƒ¨åˆ† | `FileSubagentManager` æ”¯æŒè¿›ç¨‹çº§éš”ç¦»ï¼Œä½†æœªä½œä¸ºé»˜è®¤ |

### âŒ ç¼ºå¤±çš„ç‰¹æ€§

| ç‰¹æ€§ | å®ç°çŠ¶æ€ | å½±å“ |
|------|---------|------|
| **Resume æœºåˆ¶** | âŒ ç¼ºå¤± | æ— æ³•æ¢å¤ä¸­æ–­çš„ SubAgent |
| **å¼‚æ­¥è½®è¯¢** | âŒ ç¼ºå¤± | ä¸» Agent å¿…é¡»ç­‰å¾… SubAgent å®Œæˆ |
| **åå°æ‰§è¡Œ** | âŒ ç¼ºå¤± | SubAgent æ— æ³•åœ¨åå°é•¿æ—¶é—´è¿è¡Œ |
| **çŠ¶æ€æŸ¥è¯¢ API** | âŒ ç¼ºå¤± | æ— æ³•æŸ¥è¯¢æ­£åœ¨è¿è¡Œçš„ SubAgent çŠ¶æ€ |
| **è‡ªåŠ¨æ¸…ç†** | âŒ ç¼ºå¤± | éœ€è¦æ‰‹åŠ¨æ¸…ç† SubAgent èµ„æº |
| **è¶…æ—¶æ§åˆ¶** | âŒ ç¼ºå¤± | æ²¡æœ‰è‡ªåŠ¨è¶…æ—¶æœºåˆ¶ |

## ğŸ” è¯¦ç»†å¯¹æ¯”

### 1. ç”Ÿå‘½å‘¨æœŸç®¡ç†

**Claude Codex**:
```python
# å¯åŠ¨ SubAgent
task_id = start_subagent(
    type="researcher",
    prompt="ç ”ç©¶ AI æœ€æ–°è¿›å±•",
    timeout=3600  # 1å°æ—¶è¶…æ—¶
)

# ä¸» Agent ç»§ç»­å…¶ä»–å·¥ä½œ
# ...

# ç¨åæŸ¥è¯¢çŠ¶æ€
status = query_subagent(task_id)
if status.state == "running":
    print(f"è¿›åº¦: {status.progress}%")
elif status.state == "completed":
    result = get_subagent_output(task_id)
    
# å¦‚æœéœ€è¦ï¼Œå¯ä»¥æš‚åœ
pause_subagent(task_id)

# ç¨åæ¢å¤
resume_subagent(task_id)

# æ¸…ç†
cleanup_subagent(task_id)
```

**Aster å½“å‰å®ç°**:
```go
// å¯åŠ¨ SubAgentï¼ˆåŒæ­¥ç­‰å¾…ï¼‰
result, err := subagent.Execute(ctx, description, parentContext)
// ä¸» Agent é˜»å¡ç­‰å¾…ç»“æœ

// âŒ æ— æ³•æŸ¥è¯¢çŠ¶æ€
// âŒ æ— æ³•æš‚åœ/æ¢å¤
// âŒ æ— æ³•å¼‚æ­¥æ‰§è¡Œ
```

**Aster çš„ FileSubagentManagerï¼ˆæœªå®Œå…¨é›†æˆï¼‰**:
```go
// æœ‰åŸºç¡€çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œä½†æœªä¸ SubAgentMiddleware é›†æˆ
manager := builtin.NewFileSubagentManager()

// å¯åŠ¨
instance, _ := manager.StartSubagent(ctx, config)

// æŸ¥è¯¢çŠ¶æ€
status, _ := manager.GetSubagent(instance.ID)

// åœæ­¢
manager.StopSubagent(instance.ID)

// âš ï¸ ä½†è¿™äº›åŠŸèƒ½æœªæš´éœ²ç»™ task å·¥å…·
```

### 2. çŠ¶æ€æŒä¹…åŒ–

**Claude Codex**:
```python
# è‡ªåŠ¨æŒä¹…åŒ–
task_id = start_subagent(...)

# å³ä½¿ä¸»ç¨‹åºå´©æºƒï¼ŒSubAgent çŠ¶æ€ä¹Ÿè¢«ä¿å­˜
# é‡å¯åå¯ä»¥æ¢å¤
task_ids = list_subagents()
for task_id in task_ids:
    if get_status(task_id) == "running":
        # å¯ä»¥é€‰æ‹©æ¢å¤æˆ–æ¸…ç†
        resume_subagent(task_id)
```

**Aster å½“å‰å®ç°**:
```go
// âŒ SubAgent çŠ¶æ€ä¸æŒä¹…åŒ–
// âŒ ä¸» Agent å…³é—­åï¼ŒSubAgent çŠ¶æ€ä¸¢å¤±
// âŒ æ— æ³•æ¢å¤ä¸­æ–­çš„ä»»åŠ¡

// FileSubagentManager æœ‰æŒä¹…åŒ–ï¼Œä½†æœªé›†æˆ
```

### 3. å¼‚æ­¥æ‰§è¡Œ

**Claude Codex**:
```python
# å¯åŠ¨å¤šä¸ªé•¿æ—¶é—´è¿è¡Œçš„ SubAgent
task1 = start_subagent("researcher", "æ·±åº¦ç ”ç©¶ä¸»é¢˜A")
task2 = start_subagent("researcher", "æ·±åº¦ç ”ç©¶ä¸»é¢˜B")
task3 = start_subagent("researcher", "æ·±åº¦ç ”ç©¶ä¸»é¢˜C")

# ä¸» Agent ç«‹å³è¿”å›ï¼Œç»§ç»­å¤„ç†å…¶ä»–ä»»åŠ¡
# SubAgent åœ¨åå°è¿è¡Œ

# ç¨åè½®è¯¢æ£€æŸ¥
while True:
    statuses = [query_subagent(t) for t in [task1, task2, task3]]
    if all(s.state == "completed" for s in statuses):
        break
    time.sleep(10)  # æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡

# æ”¶é›†ç»“æœ
results = [get_output(t) for t in [task1, task2, task3]]
```

**Aster å½“å‰å®ç°**:
```go
// âœ… æ”¯æŒå¹¶è¡Œå¯åŠ¨
// âŒ ä½†ä¸» Agent å¿…é¡»ç­‰å¾…æ‰€æœ‰ SubAgent å®Œæˆ
// âŒ æ— æ³•å¼‚æ­¥è½®è¯¢
// âŒ æ— æ³•åœ¨åå°é•¿æ—¶é—´è¿è¡Œ

// å¹¶è¡Œæ‰§è¡Œï¼ˆä½†ä»ç„¶æ˜¯åŒæ­¥ç­‰å¾…ï¼‰
result1, _ := subagent1.Execute(ctx, desc1, nil)  // é˜»å¡
result2, _ := subagent2.Execute(ctx, desc2, nil)  // é˜»å¡
result3, _ := subagent3.Execute(ctx, desc3, nil)  // é˜»å¡
```

### 4. èµ„æºç›‘æ§

**Claude Codex**:
```python
status = query_subagent(task_id)
print(f"CPU: {status.cpu_percent}%")
print(f"Memory: {status.memory_mb} MB")
print(f"Runtime: {status.runtime_seconds}s")
print(f"Token usage: {status.tokens_used}")

# è‡ªåŠ¨è¶…æ—¶
if status.runtime > timeout:
    stop_subagent(task_id)
```

**Aster å½“å‰å®ç°**:
```go
// FileSubagentManager æœ‰åŸºç¡€ç›‘æ§
instance, _ := manager.GetSubagent(taskID)
if instance.ResourceUsage != nil {
    fmt.Printf("Memory: %.2f MB\n", instance.ResourceUsage.MemoryMB)
    fmt.Printf("CPU: %.2f%%\n", instance.ResourceUsage.CPUPercent)
}

// âš ï¸ ä½†æœªé›†æˆåˆ° SubAgentMiddleware
// âŒ æ²¡æœ‰è‡ªåŠ¨è¶…æ—¶æœºåˆ¶
// âŒ æ²¡æœ‰èµ„æºé…é¢é™åˆ¶
```

### 5. è¿›ç¨‹éš”ç¦»

**Claude Codex**:
```python
# æ¯ä¸ª SubAgent è¿è¡Œåœ¨ç‹¬ç«‹è¿›ç¨‹ä¸­
# å®Œå…¨çš„å†…å­˜éš”ç¦»
# å´©æºƒä¸å½±å“ä¸» Agent
task_id = start_subagent(
    type="code-executor",
    prompt="æ‰§è¡Œç”¨æˆ·ä»£ç ",
    sandbox=True,  # æ²™ç®±éš”ç¦»
    resource_limits={
        "max_memory_mb": 512,
        "max_cpu_percent": 50,
        "max_runtime_seconds": 300
    }
)
```

**Aster å½“å‰å®ç°**:
```go
// âŒ SubAgent è¿è¡Œåœ¨åŒä¸€è¿›ç¨‹ä¸­ï¼ˆgoroutineï¼‰
// âŒ å…±äº«å†…å­˜ç©ºé—´
// âš ï¸ å´©æºƒå¯èƒ½å½±å“ä¸» Agent

// FileSubagentManager æ”¯æŒè¿›ç¨‹éš”ç¦»ï¼Œä½†æœªä½œä¸ºé»˜è®¤
```

## ğŸ¯ æ”¹è¿›å»ºè®®

### ä¼˜å…ˆçº§ 1ï¼šé›†æˆ FileSubagentManager

**é—®é¢˜**ï¼š`FileSubagentManager` å·²ç»å®ç°äº†å¾ˆå¤šé«˜çº§ç‰¹æ€§ï¼Œä½†æœªä¸ `SubAgentMiddleware` é›†æˆã€‚

**å»ºè®®**ï¼š
```go
// 1. ä¿®æ”¹ SubAgentMiddleware ä½¿ç”¨ FileSubagentManager
type SubAgentMiddleware struct {
    *BaseMiddleware
    manager        SubagentManager  // ä½¿ç”¨ SubagentManager æ¥å£
    enableParallel bool
    mu             sync.RWMutex
}

// 2. ä¿®æ”¹ task å·¥å…·æ”¯æŒå¼‚æ­¥æ‰§è¡Œ
func (t *TaskTool) Execute(ctx context.Context, input map[string]interface{}, tc *tools.ToolContext) (interface{}, error) {
    // å¯åŠ¨ SubAgentï¼ˆå¼‚æ­¥ï¼‰
    instance, err := t.middleware.manager.StartSubagent(ctx, config)
    
    // è¿”å› task_idï¼Œè€Œä¸æ˜¯ç­‰å¾…ç»“æœ
    return map[string]interface{}{
        "ok":      true,
        "task_id": instance.ID,
        "status":  "started",
    }, nil
}

// 3. æ·»åŠ æ–°å·¥å…·ï¼šquery_subagent
type QuerySubagentTool struct {
    middleware *SubAgentMiddleware
}

func (t *QuerySubagentTool) Execute(ctx context.Context, input map[string]interface{}, tc *tools.ToolContext) (interface{}, error) {
    taskID := input["task_id"].(string)
    instance, err := t.middleware.manager.GetSubagent(taskID)
    
    return map[string]interface{}{
        "task_id": taskID,
        "status":  instance.Status,
        "output":  instance.Output,
        "progress": calculateProgress(instance),
    }, nil
}
```

### ä¼˜å…ˆçº§ 2ï¼šæ·»åŠ  Resume æœºåˆ¶

**é—®é¢˜**ï¼šæ— æ³•æ¢å¤ä¸­æ–­çš„ SubAgentã€‚

**å»ºè®®**ï¼š
```go
// 1. åœ¨ SubagentManager ä¸­æ·»åŠ  Resume æ–¹æ³•ï¼ˆå·²æœ‰ï¼‰
// 2. æ·»åŠ  resume_subagent å·¥å…·
type ResumeSubagentTool struct {
    middleware *SubAgentMiddleware
}

func (t *ResumeSubagentTool) Execute(ctx context.Context, input map[string]interface{}, tc *tools.ToolContext) (interface{}, error) {
    taskID := input["task_id"].(string)
    instance, err := t.middleware.manager.ResumeSubagent(taskID)
    
    return map[string]interface{}{
        "ok":      true,
        "task_id": instance.ID,
        "status":  instance.Status,
    }, nil
}

// 3. åœ¨ä¸» Agent å¯åŠ¨æ—¶è‡ªåŠ¨æ¢å¤æœªå®Œæˆçš„ SubAgent
func (m *SubAgentMiddleware) OnAgentStart(ctx context.Context, agentID string) error {
    // åˆ—å‡ºæ‰€æœ‰ SubAgent
    instances, _ := m.manager.ListSubagents()
    
    // æ¢å¤æœªå®Œæˆçš„
    for _, instance := range instances {
        if instance.Status == "running" || instance.Status == "starting" {
            log.Printf("Resuming subagent: %s", instance.ID)
            _, _ = m.manager.ResumeSubagent(instance.ID)
        }
    }
    
    return nil
}
```

### ä¼˜å…ˆçº§ 3ï¼šå¼‚æ­¥è½®è¯¢æœºåˆ¶

**é—®é¢˜**ï¼šä¸» Agent å¿…é¡»ç­‰å¾… SubAgent å®Œæˆã€‚

**å»ºè®®**ï¼š
```go
// 1. ä¿®æ”¹ task å·¥å…·æ”¯æŒ async å‚æ•°
func (t *TaskTool) InputSchema() map[string]interface{} {
    return map[string]interface{}{
        "type": "object",
        "properties": map[string]interface{}{
            "description": map[string]interface{}{
                "type": "string",
                "description": "Task description",
            },
            "subagent_type": map[string]interface{}{
                "type": "string",
                "description": "SubAgent type",
            },
            "async": map[string]interface{}{
                "type": "boolean",
                "description": "Run asynchronously (default: false)",
                "default": false,
            },
        },
        "required": []string{"description", "subagent_type"},
    }
}

// 2. å¼‚æ­¥æ‰§è¡Œé€»è¾‘
func (t *TaskTool) Execute(ctx context.Context, input map[string]interface{}, tc *tools.ToolContext) (interface{}, error) {
    async := input["async"].(bool)
    
    if async {
        // å¼‚æ­¥å¯åŠ¨
        instance, _ := t.middleware.manager.StartSubagent(ctx, config)
        return map[string]interface{}{
            "ok":      true,
            "task_id": instance.ID,
            "status":  "started",
            "message": "SubAgent started in background. Use query_subagent to check status.",
        }, nil
    } else {
        // åŒæ­¥ç­‰å¾…ï¼ˆå½“å‰è¡Œä¸ºï¼‰
        // ...
    }
}
```

### ä¼˜å…ˆçº§ 4ï¼šè¶…æ—¶å’Œèµ„æºé™åˆ¶

**é—®é¢˜**ï¼šæ²¡æœ‰è‡ªåŠ¨è¶…æ—¶å’Œèµ„æºé…é¢æ§åˆ¶ã€‚

**å»ºè®®**ï¼š
```go
// 1. åœ¨ SubagentConfig ä¸­æ·»åŠ é™åˆ¶
type SubagentConfig struct {
    // ... ç°æœ‰å­—æ®µ
    
    // èµ„æºé™åˆ¶
    Timeout         time.Duration     `json:"timeout,omitempty"`
    MaxMemoryMB     int               `json:"max_memory_mb,omitempty"`
    MaxCPUPercent   float64           `json:"max_cpu_percent,omitempty"`
    MaxTokens       int               `json:"max_tokens,omitempty"`
}

// 2. åœ¨ monitorSubagent ä¸­å®ç°é™åˆ¶
func (sm *FileSubagentManager) monitorSubagent(ctx context.Context, instance *SubagentInstance, cmd *exec.Cmd, outFile *os.File) {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    timeout := instance.Config.Timeout
    if timeout == 0 {
        timeout = 1 * time.Hour // é»˜è®¤1å°æ—¶
    }
    
    timeoutTimer := time.NewTimer(timeout)
    defer timeoutTimer.Stop()
    
    for {
        select {
        case <-timeoutTimer.C:
            // è¶…æ—¶ï¼Œç»ˆæ­¢è¿›ç¨‹
            log.Printf("SubAgent %s timeout, killing process", instance.ID)
            _ = cmd.Process.Kill()
            instance.Status = "timeout"
            instance.Error = "execution timeout"
            return
            
        case <-ticker.C:
            // æ£€æŸ¥èµ„æºä½¿ç”¨
            sm.updateResourceUsage(instance)
            
            if instance.ResourceUsage != nil {
                // æ£€æŸ¥å†…å­˜é™åˆ¶
                if instance.Config.MaxMemoryMB > 0 && 
                   instance.ResourceUsage.MemoryMB > float64(instance.Config.MaxMemoryMB) {
                    log.Printf("SubAgent %s exceeded memory limit", instance.ID)
                    _ = cmd.Process.Kill()
                    instance.Status = "resource_limit_exceeded"
                    instance.Error = "memory limit exceeded"
                    return
                }
                
                // æ£€æŸ¥ CPU é™åˆ¶
                if instance.Config.MaxCPUPercent > 0 && 
                   instance.ResourceUsage.CPUPercent > instance.Config.MaxCPUPercent {
                    log.Printf("SubAgent %s exceeded CPU limit", instance.ID)
                    _ = cmd.Process.Kill()
                    instance.Status = "resource_limit_exceeded"
                    instance.Error = "CPU limit exceeded"
                    return
                }
            }
            
        case <-ctx.Done():
            return
        }
    }
}
```

### ä¼˜å…ˆçº§ 5ï¼šè¿›ç¨‹çº§éš”ç¦»ï¼ˆå¯é€‰ï¼‰

**é—®é¢˜**ï¼šSubAgent è¿è¡Œåœ¨åŒä¸€è¿›ç¨‹ä¸­ï¼Œç¼ºä¹éš”ç¦»ã€‚

**å»ºè®®**ï¼š
```go
// 1. æ·»åŠ é…ç½®é€‰é¡¹
type SubAgentMiddlewareConfig struct {
    // ... ç°æœ‰å­—æ®µ
    
    // éš”ç¦»æ¨¡å¼
    IsolationMode string // "goroutine" (é»˜è®¤) æˆ– "process"
}

// 2. æ ¹æ®æ¨¡å¼é€‰æ‹©å®ç°
func NewSubAgentMiddleware(config *SubAgentMiddlewareConfig) (*SubAgentMiddleware, error) {
    var manager SubagentManager
    
    if config.IsolationMode == "process" {
        // ä½¿ç”¨è¿›ç¨‹çº§éš”ç¦»
        manager = builtin.NewFileSubagentManager()
    } else {
        // ä½¿ç”¨ goroutineï¼ˆå½“å‰å®ç°ï¼‰
        manager = NewInProcessSubagentManager()
    }
    
    // ...
}
```

## ğŸ“Š åŠŸèƒ½å®Œæ•´åº¦è¯„åˆ†

| åŠŸèƒ½ç±»åˆ« | Claude Codex | Aster å½“å‰ | Aster æ½œåŠ› |
|---------|-------------|-----------|-----------|
| **åŸºç¡€ä»»åŠ¡å§”æ´¾** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **ä¸Šä¸‹æ–‡éš”ç¦»** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **å¹¶è¡Œæ‰§è¡Œ** | â­â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­â­ |
| **çŠ¶æ€æŒä¹…åŒ–** | â­â­â­â­â­ | â­â­ | â­â­â­â­â­ |
| **Resume æœºåˆ¶** | â­â­â­â­â­ | â­ | â­â­â­â­â­ |
| **å¼‚æ­¥æ‰§è¡Œ** | â­â­â­â­â­ | â­ | â­â­â­â­ |
| **èµ„æºç›‘æ§** | â­â­â­â­â­ | â­â­ | â­â­â­â­ |
| **è¶…æ—¶æ§åˆ¶** | â­â­â­â­â­ | â­ | â­â­â­â­â­ |
| **è¿›ç¨‹éš”ç¦»** | â­â­â­â­â­ | â­â­ | â­â­â­â­ |
| **ç”Ÿå‘½å‘¨æœŸç®¡ç†** | â­â­â­â­â­ | â­â­â­ | â­â­â­â­â­ |

**æ€»ä½“è¯„åˆ†**ï¼š
- **Claude Codex**: 50/50 â­ (100%)
- **Aster å½“å‰**: 28/50 â­ (56%)
- **Aster æ½œåŠ›**: 48/50 â­ (96%)

## ğŸ¯ æ€»ç»“

### ä¼˜åŠ¿
1. âœ… **åŸºç¡€åŠŸèƒ½å®Œæ•´**ï¼šä»»åŠ¡å§”æ´¾ã€ä¸Šä¸‹æ–‡éš”ç¦»ã€å¹¶è¡Œæ‰§è¡Œéƒ½å¾ˆå¥½
2. âœ… **è®¾è®¡çµæ´»**ï¼šSubAgentSpecã€ä¸­é—´ä»¶ç»§æ‰¿ç­‰è®¾è®¡ä¼˜ç§€
3. âœ… **å·²æœ‰åŸºç¡€è®¾æ–½**ï¼šFileSubagentManager å·²å®ç°å¾ˆå¤šé«˜çº§ç‰¹æ€§

### ä¸è¶³
1. âŒ **æœªå®Œå…¨é›†æˆ**ï¼šFileSubagentManager çš„é«˜çº§ç‰¹æ€§æœªæš´éœ²ç»™ç”¨æˆ·
2. âŒ **ç¼ºå°‘å¼‚æ­¥æ”¯æŒ**ï¼šæ— æ³•åå°è¿è¡Œé•¿æ—¶é—´ä»»åŠ¡
3. âŒ **ç¼ºå°‘ Resume**ï¼šæ— æ³•æ¢å¤ä¸­æ–­çš„ä»»åŠ¡
4. âŒ **èµ„æºæ§åˆ¶ä¸è¶³**ï¼šæ²¡æœ‰è¶…æ—¶å’Œé…é¢é™åˆ¶

### å»ºè®®
1. **çŸ­æœŸ**ï¼ˆ1-2å‘¨ï¼‰ï¼šé›†æˆ FileSubagentManagerï¼Œæ·»åŠ  query_subagent å·¥å…·
2. **ä¸­æœŸ**ï¼ˆ1ä¸ªæœˆï¼‰ï¼šå®ç°å¼‚æ­¥æ‰§è¡Œå’Œ Resume æœºåˆ¶
3. **é•¿æœŸ**ï¼ˆ2-3ä¸ªæœˆï¼‰ï¼šå®Œå–„èµ„æºç›‘æ§ã€è¶…æ—¶æ§åˆ¶ã€è¿›ç¨‹éš”ç¦»

**å¥½æ¶ˆæ¯**ï¼šä½ ä»¬å·²ç»æœ‰äº† `FileSubagentManager`ï¼Œå®ƒå®ç°äº†å¾ˆå¤š Claude Codex çš„ç‰¹æ€§ï¼åªéœ€è¦å°†å®ƒä¸ `SubAgentMiddleware` é›†æˆï¼Œå°±èƒ½å¤§å¹…æå‡åŠŸèƒ½å®Œæ•´åº¦ã€‚

## ğŸ“š å‚è€ƒèµ„æº

- [Claude Extended Thinking æ–‡æ¡£](https://docs.anthropic.com/en/docs/build-with-claude/extended-thinking)
- [Aster SubAgent ç³»ç»Ÿæ–‡æ¡£](/core-concepts/subagent-system)
- [FileSubagentManager æºç ](/pkg/tools/builtin/subagent_manager.go)
